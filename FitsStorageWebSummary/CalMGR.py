"""
This module contains the calmgr html generator function. 
"""
from FitsStorage import *
from FitsStorageWebSummary.Selection import sayselection, queryselection, openquery
from FitsStorageCal import get_cal_object

import ApacheReturnCodes as apache

import urllib
import re


def calmgr(req, selection):
  """
  This is the calibration manager. It implements a machine readable calibration association server
  req is an apache request handler object
  type is the summary type required
  selection is an array of items to select on, simply passed through to the webhdrsummary function
    - in this case, this will usually be a datalabel or filename

  if this code is called via an HTTP POST request rather than a GET, it expects to
  receive a string representation of a python dictionary containing descriptor values
  and a string representation of a python array containg astrodata types
  and it will use this data as the science target details with which to associate 
  the calibration.

  returns an apache request status code
  """
  
  session = sessionfactory()
  try:
    # Was the request for only one type of calibration?
    caltype=''
    if('caltype' in selection):
      caltype = selection['caltype']
    else:
      req.content_type="text/plain"
      req.write("<!-- Error: No calibration type specified-->\n")
      return apache.HTTP_NOT_ACCEPTABLE

    # Did we get called via an HTTP POST or HTTP GET?
    if(req.method == 'POST'):
      # OK, get the details from the POST data
      req.content_type = "text/plain"
      clientdata = req.read()
      #req.write("\nclient data: %s\n" % clientdata)
      clientstr = urllib.unquote_plus(clientdata)
      #req.write("\nclient str: %s\n" % clientstr)
      match = re.match("descriptors=(.*)&types=(.*)", clientstr)
      desc_str = match.group(1)
      type_str = match.group(2)
      #req.write("\ndesc_str: %s\n" % desc_str)
      #req.write("\ntype_str: %s\n" % type_str)
      descriptors = eval(desc_str)
      types = eval(type_str)
      req.log_error("CalMGR request Descriptor Dictionary: %s\n" % descriptors)
      req.log_error("Types List: %s\n" % types)

      # OK, there are a couple of items that are handled in the DB as if they are descriptors
      # but they're actually types. This is where we push them into the descriptor disctionary
      descriptors['nodandshuffle'] = 'GMOS_NODANDSHUFFLE' in types
      descriptors['spectroscopy'] = 'SPECT' in types
      descriptors['overscan_subtracted'] = 'OVERSCAN_SUBTRACTED' in types
      descriptors['overscan_trimmed'] = 'OVERSCAN_TRIMMED' in types
      descriptors['prepared'] = 'PREPARED' in types
    

      # Get a cal object for this target data
      c = get_cal_object(session, None, header=None, descriptors=descriptors, types=types)
      req.content_type = "text/xml"
      req.write('<?xml version="1.0" ?>')
      req.write("<calibration_associations>\n")
      req.write('<!-- Generated by %s for POST request at %s / %s UTC-->' % (os.uname()[1], datetime.datetime.now(), datetime.datetime.utcnow()))
      req.write("<dataset>\n")
      req.write("<datalabel>%s</datalabel>\n" % descriptors['data_label'])

      # Call the appropriate method depending what calibration type we want
      cal = None
      if(caltype == 'bias'):
        cal = c.bias()
      if(caltype == 'dark'):
        cal = c.dark()
      if(caltype == 'flat'):
        cal = c.flat()
      if(caltype == 'arc'):
        cal = c.arc()
      if(caltype == 'processed_bias'):
        cal = c.bias(processed=True)
      if(caltype == 'processed_dark'):
        cal = c.dark(processed=True)
      if(caltype == 'processed_flat'):
        cal = c.flat(processed=True)
      if(caltype == 'processed_arc'):
        cal = c.arc(processed=True)
      if(caltype == 'processed_fringe'):
        cal = c.processed_fringe()
      if(caltype == 'pinhole_mask'):
        cal = c.pinhole_mask()
      if(caltype == 'ronchi_mask'):
        cal = c.ronchi_mask()

      if(cal):
        req.log_error("CalMGR returning: %s" % cal.diskfile.file.filename)
        req.write("<calibration>\n")
        req.write("<caltype>%s</caltype>\n" % caltype)
        req.write("<datalabel>%s</datalabel>\n" % cal.data_label)
        req.write("<filename>%s</filename>\n" % cal.diskfile.file.filename)
        req.write("<md5>%s</md5>\n" % cal.diskfile.md5)
        if(cal.diskfile.present):
          if (using_apache):
            req.write("<url>http://%s/file/%s</url>\n" % (fits_servername, cal.diskfile.file.filename))
          else:
            req.write("<url>file://%s/%s/%s</url>\n" % (storage_root, cal.diskfile.file.path, cal.diskfile.file.filename))
        else:
          # Once we are sending new stlye processed calibrations to the GSA,
          # we can form a URL to the GSA here and return that.
          req.write("<!-- Calibration Result found in DB, but file is not present on FITS server -->")
        req.write("</calibration>\n")
      else:
        req.write("<!-- NO CALIBRATION FOUND-->\n")

      req.write("</dataset>\n");
      req.write("</calibration_associations>\n")


      return apache.OK

    else:
      # OK, we got called via a GET - find the science dataset in the database
      # The Basic Query
      query = session.query(Header).select_from(join(join(File, DiskFile), Header))

      # Only the canonical versions
      selection['canonical'] = True

      query = queryselection(query, selection)

      # Knock out the FAILs
      query = query.filter(Header.qa_state!='Fail')

      # Order by date, most recent first
      query = query.order_by(desc(Header.ut_datetime))

      # If openquery, limit number of responses
      if(openquery(selection)):
        query = query.limit(1000)

      # OK, do the query
      headers = query.all()

      req.content_type = "text/xml"
      req.write('<?xml version="1.0" ?>')
      req.write("<calibration_associations>\n")
      req.write('<!-- Generated by %s for GET request at %s / %s UTC-->' % (os.uname()[1], datetime.datetime.now(), datetime.datetime.utcnow()))
      # Did we get anything?
      if(len(headers)>0):
        # Loop through targets frames we found
        for object in headers:
          req.write("<dataset>\n")
          req.write("<datalabel>%s</datalabel>\n" % object.data_label)
          req.write("<filename>%s</filename>\n" % object.diskfile.file.filename)
          req.write("<md5>%s</md5>\n" % object.diskfile.md5)

          # Get a cal object for this target data
          c = get_cal_object(session, None, header=object)
   
          # Call the appropriate method depending what calibration type we want
          cal = None
          if(caltype == 'bias'):
            cal = c.bias()
          if(caltype == 'dark'):
            cal = c.dark()
          if(caltype == 'flat'):
            cal = c.flat()
          if(caltype == 'arc'):
            cal = c.arc()
          if(caltype == 'processed_bias'):
            cal = c.bias(processed=True)
          if(caltype == 'processed_dark'):
            cal = c.dark(processed=True)
          if(caltype == 'processed_flat'):
            cal = c.flat(processed=True)
          if(caltype == 'processed_arc'):
            cal = c.arc(processed=True)
          if(caltype == 'processed_fringe'):
            cal = c.processed_fringe()
          if(caltype == 'pinhole_mask'):
            cal = c.pinhole_mask()
          if(caltype == 'ronchi_mask'):
            cal = c.ronchi_mask()

          if(cal):
            # OK, say what we found
            req.write("<calibration>\n")
            req.write("<caltype>%s</caltype>\n" % caltype)
            req.write("<datalabel>%s</datalabel>\n" % cal.data_label)
            req.write("<filename>%s</filename>\n" % cal.diskfile.file.filename)
            req.write("<md5>%s</md5>\n" % cal.diskfile.md5)
            if using_apache:
                req.write("<url>http://%s/file/%s</url>\n" % (req.server.server_hostname, cal.diskfile.file.filename))
            else:
                req.write("<url>file://%s</url>\n" % os.path.join(cal.diskfile.file.path, cal.diskfile.file.filename))
            req.write("</calibration>\n")
          else:
            req.write("<!-- NO CALIBRATION FOUND-->\n")
          req.write("</dataset>\n")
      else:
        req.write("<!-- COULD NOT LOCATE METADATA FOR DATASET -->\n")

      req.write("</calibration_associations>\n")
      return apache.OK
  except IOError:
    pass
  finally:
    session.close()

